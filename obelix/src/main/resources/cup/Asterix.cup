package asint;

import java_cup.runtime.*;
import alex.AnalizadorLexicoAsterix;
import alexop.UnidadLexica;
import alexop.TokenValue;
import errors.GestionErroresAsterix;
import java.util.List;
import ast.*;

scan with {: return getScanner().next_token(); :};
parser code {: 
   private GestionErroresAsterix errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresAsterix();
   AnalizadorLexicoAsterix alex = (AnalizadorLexicoAsterix)getScanner();
   alex.fijaGestionErrores(errores);
:};

terminal TokenValue DATIX, PUNTOCOMA, COMA, INTEGER, FLOATING, GALO, ROMANO,
    MENOR, MAYOR, CORA, CORC, PAA, PAC, LLA, LLC, MAS, MENOS, MUL, DIV, IGUAL, OR,
    AND, DIS, ASIG, MEIGUAL, MAIGUAL, MOD, POW, NOT, REF, IF, ELSE, WHILIX, PUNTO,
    FORIX, PANOR, POTION, DOSPUNTOS, FLECHA, RET, TABEL, STIL, ID;

terminal T INTIX, BOOLIX, FLOATIX, POT, VECTIX;

non terminal P programa;
non terminal Sub subprograma, main;
non terminal I i, dec, alias, ifelse, struct,while, for, tab, stilus, asignation, callf;
non terminal E exp0, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8;
non terminal Arg arg;
non terminal T tipo;

non terminal List<IDec> structint;
non terminal List<I> s;
non terminal List <DefSub> cuerpo;


non terminal List<E> lista, largc;
non terminal List<Arg> largp;
non terminal valref,listaint;

programa ::= main : submain
    {:RESULT = new P(new List<DefSub>(), submain); :};
programa ::= cuerpo: listadefsub main: submain
    {:RESULT = new P(listadefsub, submain); :};


cuerpo ::= subprograma:nuevo
    {:RESULT = new P(new List<DefSub>(), nuevo); :};
cuerpo ::= dec:nuevo PUNTOCOMA
    {:RESULT = new P(new List<DefSub>(), nuevo); :};
cuerpo ::= cuerpo:listadefSub subprograma:nuevo
    {:RESULT = new P(listadefSub, nuevo); :};
cuerpo ::= cuerpo:listadefSub dec:nuevo PUNTOCOMA
    {:RESULT = new P(listadefSub, nuevo); :};



s ::= i PUNTOCOMA s  | i PUNTOCOMA;
i  ::=  dec | for | while | ifelse | stilus | tab | alias | callf | asignation;
main ::= POTION PANOR PAA PAC FLECHA INTIX LLA s RET exp0 PUNTOCOMA LLC;
dec ::= tipo ID ASIG exp0 | tipo ID | struct | ID ID ASIG exp0 | ID ID ;
asignation ::= exp0 ASIG exp0;
lista ::= LLA LLC | LLA listaint LLC;
listaint ::= exp0 | listaint COMA exp0 ;
alias ::= DATIX ID tipo | DATIX ID struct; 
tipo ::= INTIX | BOOLIX | FLOATIX | VECTIX MENOR tipo MAYOR CORA INTEGER CORC; 
struct ::= POT ID CORA structint CORC;
structint ::= structint dec PUNTOCOMA  | dec PUNTOCOMA;
subprograma ::= POTION ID largp LLA s LLC | POTION ID largp FLECHA tipo LLA s RET exp0 PUNTOCOMA LLC;
largp ::= PAA PAC | PAA arg PAC;
arg ::= arg COMA ID DOSPUNTOS valref | ID DOSPUNTOS valref;
valref ::= tipo | REF tipo | ID | REF ID;
callf ::= ID PAA PAC | ID PAA largc PAC;
largc ::= largc COMA exp0 | exp0;
ifelse ::= IF PAA exp0 PAC LLA s LLC | IF PAA exp0 PAC LLA s LLC ELSE LLA s LLC;
while ::= WHILIX PAA exp0 PAC LLA s LLC;
for ::= FORIX PAA tipo ID DOSPUNTOS ID PAC LLA s LLC;
tab ::= TABEL PAA exp0 PAC;
stilus ::= STIL PAA exp0 PAC;

exp0 ::= exp1 OR exp0 | exp1;
exp1 ::= exp2 AND exp1 | exp2;
exp2 ::= exp3 IGUAL exp2 | exp3 DIS exp2 | exp3;
exp3 ::= exp4 MEIGUAL exp3 | exp4 MAIGUAL exp3 | exp4 MENOR exp3 | exp4 MAYOR exp3 | exp4;
exp4 ::= exp4 MAS exp5 | exp4 MENOS exp5 | exp5;
exp5 ::= exp5 MUL exp6 | exp5 DIV exp6 | exp5 MOD exp6 | exp6;
exp6 ::= NOT exp7 | MENOS exp6 | exp7 POW exp6 | exp7;
exp7 ::= exp7 PUNTO exp8 | exp7 CORA exp8 CORC | exp8;
exp8 ::= ID | INTEGER | FLOATING | GALO | ROMANO | lista | callf | PAA exp0 PAC;
