package asint;

import java_cup.runtime.*;
import alex.AnalizadorLexicoAsterix;
import alexop.UnidadLexica;
import alexop.TokenValue;
import errors.GestionErroresAsterix;
import java.util.List;
import java.util.ArrayList;
import ast.*;

scan with {: return getScanner().next_token(); :};
parser code {: 
   private GestionErroresAsterix errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresAsterix();
   AnalizadorLexicoAsterix alex = (AnalizadorLexicoAsterix)getScanner();
   alex.fijaGestionErrores(errores);
:};

terminal TokenValue PUNTOCOMA, COMA, INTEGER, FLOATING, GALO, ROMANO,
    MENOR, MAYOR, CORA, CORC, PAA, PAC, LLA, LLC, MAS, MENOS, MUL, DIV, IGUAL, OR,
    AND, DIS, ASIG, MEIGUAL, MAIGUAL, MOD, POW, NOT, REF, IF, ELSE, WHILIX, PUNTO,
    FORIX, PANOR, POTION, DOSPUNTOS, FLECHA, RET, TABEL, STIL, ID,
    INTIX, BOOLIX, FLOATIX, POT, VECTIX, DATIX;

non terminal P programa;
non terminal S subprograma, main;
non terminal I i, ifelse, while, for, tab, stilus, asignation, callf;
non terminal IDec dec,struct;
non terminal IAlias alias;
non terminal E exp0, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, exp9;
non terminal T tipo;

non terminal List<IDec> structint;
non terminal List<I> s;
non terminal List<DefSub> cuerpo;

non terminal List<E> lista, largc, listaint;
non terminal List<Arg> largp, args;

programa ::= main : submain
    {:RESULT = new P(new ArrayList<DefSub>(), submain); :};
programa ::= cuerpo: listadefsub main: submain
    {:RESULT = new P(listadefsub, submain); :};

cuerpo ::= subprograma:nuevo
    {: List<DefSub> lista = new ArrayList<DefSub>();
       lista.add(nuevo);
       RESULT = lista; :};
cuerpo ::= dec:nuevo
    {: List<DefSub> lista = new ArrayList<DefSub>();
       lista.add(nuevo);
       RESULT = lista; :};
cuerpo ::= alias:nuevo
    {: List<DefSub> lista = new ArrayList<DefSub>();
       lista.add(nuevo);
       RESULT = lista; :};
cuerpo ::= cuerpo:listadefSub subprograma:nuevo
    {: listadefSub.add(nuevo);
    RESULT = listadefSub; :};
cuerpo ::= cuerpo:listadefSub dec:nuevo
    {: listadefSub.add(nuevo);
    RESULT = listadefSub; :};
cuerpo ::= cuerpo:listadefSub alias:nuevo
    {: listadefSub.add(nuevo);
    RESULT = listadefSub; :};

s ::= s:listains i:nuevo
    {: listains.add(nuevo);
        RESULT = listains; :};
s ::=  i:ins
    {: List<I> listains = new ArrayList<I>();
       listains.add(ins);
       RESULT = listains; :};

i ::= dec:idec PUNTOCOMA
    {: RESULT = idec; :};
i ::= for:ifor
    {: RESULT = ifor; :};
i ::= while:iwhile
    {: RESULT = iwhile; :};
i ::= ifelse:iif
    {: RESULT = iif; :};
i ::= stilus:istilus PUNTOCOMA
    {: RESULT = istilus; :};
i ::= tab:itab PUNTOCOMA
    {: RESULT = itab; :};
i ::= asignation:iasig PUNTOCOMA
    {: RESULT = iasig; :};
i ::= callf:icall PUNTOCOMA
    {: RESULT = icall; :};
i ::= alias:ialias PUNTOCOMA
    {: RESULT = ialias; :};

main ::= POTION PANOR PAA PAC FLECHA INTIX LLA s:cuerpo RET exp0:vRet PUNTOCOMA LLC
    {: RESULT = new  S(cuerpo,vRet); :};

dec ::= tipo:type ID:id ASIG exp0:valor
    {: RESULT = new IDecVar(type, id.lexema, valor); :};
dec ::= tipo:type ID:id
    {: RESULT = new IDecVar(type, id.lexema); :};
dec ::= struct:decStruct
    {: RESULT = decStruct; :};

asignation ::= exp0:id ASIG exp0:valor
    {: RESULT = new IAsig(id, valor); :};

alias ::= DATIX ID:id tipo:type
    {: RESULT = new IAlias(id.lexema, type); :};

lista ::= LLA LLC
    {: RESULT = new ArrayList(); :};
lista ::= LLA listaint:listaexp LLC
    {: RESULT = listaexp; :};

listaint ::= exp0:nuevo
    {: List<E> listaexp = new ArrayList();
       listaexp.add(nuevo);
       RESULT = listaexp; :};
listaint ::= listaint:listaexp COMA exp0:nuevo
    {: listaexp.add(nuevo);
       RESULT = listaexp; :};

tipo ::= INTIX:ent
    {: RESULT = new T(ent.lexema); :};
tipo ::= ID:id
    {: RESULT = new T(id.lexema); :};
tipo ::= BOOLIX:bool
    {: RESULT = new T(bool.lexema); :};
tipo ::= FLOATIX:real
    {: RESULT = new T(real.lexema); :};
tipo ::= VECTIX MENOR tipo:type MAYOR CORA INTEGER:tam CORC
    {: RESULT = new T(type, tam.lexema); :};

struct ::= POT ID:id LLA structint:listdec LLC
    {: RESULT = new IDecStruct(id.lexema, listdec);:};

structint ::= structint:listadec dec:nuevo PUNTOCOMA
    {: listadec.add(nuevo);
       RESULT = listadec;:};
structint ::= dec:nuevo PUNTOCOMA
    {: List<IDec> listadec= new ArrayList<IDec>();
       listadec.add(nuevo);
       RESULT = listadec;:};

subprograma ::= POTION ID:id largp:args LLA s:cuerpo LLC
    {:RESULT = new S(cuerpo, args, id.lexema);:};
subprograma ::= POTION ID:id largp:args FLECHA tipo:tRet LLA s:cuerpo RET exp0:vRet PUNTOCOMA LLC
    {:RESULT = new S(cuerpo, args, id.lexema, tRet, vRet);:};

largp ::= PAA PAC
    {:RESULT = new ArrayList<Arg>();:};
largp ::= PAA args:listargs PAC
    {:RESULT = listargs;:};

args ::= args:lista COMA ID:id DOSPUNTOS tipo:t
    {:lista.add(new Arg(t,id.lexema,false));
    RESULT = lista;:};
args ::= args:lista COMA ID:id DOSPUNTOS REF tipo:t
    {:lista.add(new Arg(t,id.lexema,true));
    RESULT = lista;:};
args ::= ID:id DOSPUNTOS tipo:t
    {: List<Arg> args = new ArrayList<Arg>();
       args.add(new Arg(t,id.lexema,false));
    RESULT = args;:};
args ::= ID:id DOSPUNTOS REF tipo:t
    {: List<Arg> args = new ArrayList<Arg>();
       args.add(new Arg(t,id.lexema,true));
    RESULT = args;:};

callf ::= ID:id PAA PAC
    {:RESULT = new ICall(id.lexema);:};
callf ::= ID:id PAA largc:params PAC
    {:RESULT = new ICall(params, id.lexema);:};

largc ::= largc:lista COMA exp0:valor
    {: lista.add(valor);
    RESULT = lista;:};
largc ::= exp0:valor
    {: List<E> lista = new ArrayList<E>();
       lista.add(valor);
       RESULT = lista; :};

ifelse ::= IF PAA exp0:cond PAC LLA s:cuerpo LLC
    {:RESULT = new IIf(cond,cuerpo);:};
ifelse ::= IF PAA exp0:cond PAC LLA s:cuerpoIf LLC ELSE LLA s:cuerpoElse LLC
    {:RESULT = new IIf(cond,cuerpoIf,cuerpoElse);:};

while ::= WHILIX PAA exp0:cond PAC LLA s:cuerpo LLC
    {:RESULT = new IWhile(cond,cuerpo);:};

for ::= FORIX PAA tipo:t ID:id DOSPUNTOS ID PAC LLA s:cuerpo LLC
    {:RESULT = new IFor(t,id.lexema,cuerpo);:};

tab ::= TABEL:op PAA exp0:valor PAC
    {:RESULT = new IES(valor,op.lexema);:};

stilus ::= STIL:op PAA exp0:valor PAC
    {:RESULT = new IES(valor,op.lexema);:};

exp0 ::= exp1:valor1 OR exp0:valor2
    {:RESULT = new EBin(valor1,valor2, "or");:};
exp0 ::= exp1:valor
    {:RESULT = valor;:};

exp1 ::= exp2:valor1 AND exp1:valor2
    {:RESULT = new EBin(valor1,valor2, "and");:};
exp1 ::= exp2:valor
    {:RESULT = valor;:};

exp2 ::= exp3:valor1 IGUAL exp2:valor2
    {:RESULT = new EBin(valor1,valor2, "igual");:};
exp2 ::= exp3:valor1 DIS:op exp2:valor2
    {:RESULT = new EBin(valor1,valor2, "dis");:};
exp2 ::= exp3:valor
    {:RESULT = valor;:};

exp3 ::= exp4:valor1 MEIGUAL exp3:valor2
    {:RESULT = new EBin(valor1,valor2, "leq");:};
exp3 ::= exp4:valor1 MAIGUAL exp3:valor2
    {:RESULT = new EBin(valor1,valor2, "geq");:};
exp3 ::= exp4:valor1 MENOR exp3:valor2
    {:RESULT = new EBin(valor1,valor2, "menor");:};
exp3 ::= exp4:valor1 MAYOR exp3:valor2
    {:RESULT = new EBin(valor1,valor2, "mayor");:};
exp3 ::= exp4:valor
    {:RESULT = valor;:};

exp4 ::= exp4:valor1 MAS exp5:valor2
    {:RESULT = new EBin(valor1,valor2, "mas");:};
exp4 ::= exp4:valor1 MENOS exp5:valor2
    {:RESULT = new EBin(valor1,valor2, "menos");:};
exp4 ::= exp5:valor
    {:RESULT = valor;:};

exp5 ::= exp5:valor1 MUL exp6:valor2
    {:RESULT = new EBin(valor1,valor2, "mul");:};
exp5 ::= exp5:valor1 DIV exp6:valor2
    {:RESULT = new EBin(valor1,valor2, "div");:};
exp5 ::= exp5:valor1 MOD:op exp6:valor2
    {:RESULT = new EBin(valor1,valor2, "mod");:};
exp5 ::= exp6:valor
    {:RESULT = valor;:};

exp6 ::= NOT exp7:valor
    {:RESULT = new EUn(valor, "not");:};
exp6 ::= exp7:valor1 POW exp6:valor2
    {:RESULT = new EBin(valor1,valor2, "pow");:};
exp6 ::= exp7:valor
    {:RESULT = valor;:};

exp7 ::= exp7:valor1 PUNTO:op exp8:valor2
    {:RESULT = new EBin(valor1,valor2, "accS");:};
exp7 ::= exp7:valor1 CORA exp0:valor2 CORC
    {:RESULT = new EBin(valor1,valor2, "accA");:};
exp7 ::= exp8:valor
    {:RESULT = valor;:};

exp8 ::= MENOS exp9:valor
    {:RESULT = new EUn(valor, "menos"); :};
exp8 ::= exp9:valor
    {:RESULT = valor; :};

exp9 ::= INTEGER:valor
    {: RESULT = new ECte(valor.lexema);:};
exp9 ::= FLOATING:valor
    {: RESULT = new ECte(valor.lexema);:};
exp9 ::= GALO:valor
    {: RESULT = new ECte(valor.lexema);:};
exp9 ::= ROMANO:valor
    {: RESULT = new ECte(valor.lexema);:};
exp9 ::= lista:valor
    {: RESULT = new ELista(valor);:};
exp9 ::= ID:id PAA PAC
    {: RESULT = new ECall(id.lexema);:};
exp9 ::= ID:id PAA largc:params PAC
    {: RESULT = new ECall(params,id.lexema);:};
exp9 ::= ID:id
    {: RESULT = new ECte(id.lexema);:};
exp9 ::= PAA exp0:valor PAC
    {: RESULT = valor;:};
